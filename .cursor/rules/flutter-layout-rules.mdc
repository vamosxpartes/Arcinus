---
description: ui desing rule
globs: 
alwaysApply: false
---
# Reglas para Diseño de UI en Flutter

## Reglas para evitar errores de renderización y scroll

### Problema con Column/Row y Expanded dentro de ScrollView

```dart
// ❌ NO HAGAS ESTO - Causa error "Flex children have non-zero flex but incoming height constraints are unbounded"
SingleChildScrollView(
  child: Column(
    children: [
      Text('Contenido normal'),
      Expanded(child: MyWidget()) // ❌ ERROR: Expanded dentro de altura ilimitada
    ],
  ),
)

// ✅ SOLUCIÓN 1: Usa IntrinsicHeight para dar altura definida
SingleChildScrollView(
  child: IntrinsicHeight(
    child: Column(
      children: [
        Text('Contenido normal'),
        Expanded(child: MyWidget()) // Ahora funciona porque IntrinsicHeight define una altura
      ],
    ),
  ),
)

// ✅ SOLUCIÓN 2: Reemplaza Expanded con Flexible + FlexFit.loose
SingleChildScrollView(
  child: Column(
    mainAxisSize: MainAxisSize.min, // Importante
    children: [
      Text('Contenido normal'),
      Flexible(
        fit: FlexFit.loose, // Flexible con loose fit en lugar de Expanded
        child: MyWidget(),
      )
    ],
  ),
)

// ✅ SOLUCIÓN 3: Define una altura fija con SizedBox o Container
SingleChildScrollView(
  child: Column(
    children: [
      Text('Contenido normal'),
      SizedBox(
        height: 200, // Altura explícita
        child: MyWidget(),
      )
    ],
  ),
)
```

### Reglas generales para usar Expanded, Flexible y Column/Row

1. **Regla principal**: Nunca uses `Expanded` o `Flexible` dentro de un `SingleChildScrollView` si no hay un contenedor padre con altura finita

2. **¿Cuándo usar cada widget?**:
   - `Expanded`: Solo dentro de `Row` o `Column` cuando el contenedor padre tiene dimensiones definidas
   - `Flexible`: Para más control, permite que el widget hijo sea más pequeño que el espacio disponible
   - `SizedBox`: Para dimensiones fijas explícitas
   - `ConstrainedBox`: Para aplicar restricciones más complejas

3. **Para layouts con scroll**:
   - Usa `ListView` en lugar de `Column` dentro de `SingleChildScrollView`
   - Si necesitas ambos scrolling y layout flexible, considera usar `CustomScrollView` con `SliverList`

### Soluciones para Stepper con errores de renderizado

```dart
// ❌ PROBLEMA: Stepper dentro de Column en un SingleChildScrollView
SingleChildScrollView(
  child: Column(
    children: [
      // ... otros widgets
      Stepper( // Causa problemas porque internamente usa Expanded
        // ...
      ),
    ],
  ),
)

// ✅ SOLUCIÓN 1: Envolver solo el Stepper en un SizedBox con altura fija
SingleChildScrollView(
  child: Column(
    children: [
      // ... otros widgets
      SizedBox(
        height: 500, // Altura fija para el Stepper
        child: Stepper(
          // ...
        ),
      ),
    ],
  ),
)

// ✅ SOLUCIÓN 2: Usar un ConstrainedBox para el Stepper
SingleChildScrollView(
  child: Column(
    children: [
      // ... otros widgets
      ConstrainedBox(
        constraints: BoxConstraints(
          minHeight: MediaQuery.of(context).size.height * 0.7, // 70% de la altura de pantalla
        ),
        child: Stepper(
          // ...
        ),
      ),
    ],
  ),
)
```

### Cómo estructurar correctamente layouts complejos

```dart
// ✅ PATRÓN RECOMENDADO para formularios con pasos:
Scaffold(
  appBar: AppBar(title: Text('Formulario con pasos')),
  body: Column(
    children: [
      // Widgets fijos (no scrollables) como encabezados
      Container(
        height: 100,
        child: HeaderWidget(),
      ),
      
      // Contenido scrollable que ocupa el resto del espacio
      Expanded(
        child: SingleChildScrollView(
          child: Padding(
            padding: EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min, // Importante
              children: [
                // Contenido del formulario
                FormFieldsWidget(),
                
                // Botones de acción
                ActionButtonsWidget(),
              ],
            ),
          ),
        ),
      ),
    ],
  ),
)
```

### Consejos finales

1. Usa `LayoutBuilder` para acceder a las restricciones del padre y adaptar tu layout en consecuencia
2. Considera siempre `mainAxisSize: MainAxisSize.min` para Columns dentro de scrollables
3. Evita tener múltiples niveles de `Expanded` anidados para evitar comportamientos inesperados
4. Prueba tu UI en diferentes tamaños de pantalla para detectar errores de layout

---

Con estas reglas, podrás evitar la mayoría de los problemas comunes de renderizado en Flutter relacionados con layouts flexibles y scrollables.
